<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Snake Game - Veggie Style</title>
    <style>
        body {
            background-color: white;
            font-family: Georgia, serif;
            color: black;
            margin: 0;
            padding: 0;
            display: flex;
            min-height: 100vh;
            align-items: center;
            justify-content: center;
        }

        .game-wrapper {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 16px 20px 20px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            max-width: 480px;
            text-align: center;
        }

        h1 {
            font-weight: bold;
            margin: 0 0 8px;
        }

        p {
            margin: 4px 0;
            font-size: 0.9rem;
        }

        #gameCanvas {
            display: block;
            margin: 12px auto 8px;
            border: 1px solid #aaa;
            background-color: #fdfdfd;
        }

        .info-bar {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            margin-top: 4px;
        }

        .label {
            font-weight: bold;
        }
    </style>
</head>
<body>
<div class="game-wrapper">
    <h1>Snake (Veggie Mode)</h1>
    <p>Use the arrow keys to move. Eat the fruit to grow.</p>
    <p>The fruit moves to a new spot every <span class="label">5 seconds</span> if you donâ€™t eat it!</p>

    <canvas id="gameCanvas" width="400" height="400"></canvas>

    <div class="info-bar">
        <div><span class="label">Score:</span> <span id="score">0</span></div>
        <div><span class="label">Status:</span> <span id="statusText">Playing</span></div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const statusEl = document.getElementById('statusText');

    // Grid setup
    const tileCount = 20;      // 20 x 20 grid
    const tileSize = canvas.width / tileCount;

    // Snake state
    let snake = [{ x: 10, y: 10 }];
    let dx = 1;    // horizontal direction (1 = right, -1 = left)
    let dy = 0;    // vertical direction (1 = down, -1 = up)
    let pendingDirection = { dx: 1, dy: 0 }; // to handle fast key presses

    let fruit = { x: 5, y: 5 };
    let score = 0;

    let gameOver = false;

    // Fruit movement timer
    let lastFruitMoveTime = Date.now();
    const fruitMoveInterval = 5000; // 5 seconds

    // Game speed
    const gameTickMs = 120;   // lower = faster

    function resetGame() {
        snake = [{ x: 10, y: 10 }];
        dx = 1;
        dy = 0;
        pendingDirection = { dx: 1, dy: 0 };
        placeFruit();
        score = 0;
        updateScore();
        gameOver = false;
        statusEl.textContent = 'Playing';
        lastFruitMoveTime = Date.now();
    }

    function updateScore() {
        scoreEl.textContent = score;
    }

    function placeFruit() {
        // Place fruit on a random empty tile (not on the snake)
        let newX, newY, collision;
        do {
            collision = false;
            newX = Math.floor(Math.random() * tileCount);
            newY = Math.floor(Math.random() * tileCount);
            for (let seg of snake) {
                if (seg.x === newX && seg.y === newY) {
                    collision = true;
                    break;
                }
            }
        } while (collision);

        fruit.x = newX;
        fruit.y = newY;
        lastFruitMoveTime = Date.now(); // reset fruit timer every time it moves
    }

    function gameLoop() {
        if (gameOver) return;

        // Handle delayed direction update to avoid two turns in one frame
        dx = pendingDirection.dx;
        dy = pendingDirection.dy;

        moveSnake();
        checkCollisions();
        checkFruit();
        maybeMoveFruitByTime();
        drawGame();
    }

    function moveSnake() {
        const head = snake[0];
        const newHead = {
            x: head.x + dx,
            y: head.y + dy
        };
        snake.unshift(newHead); // add new head
        snake.pop();            // remove tail (unless we just ate fruit)
    }

    function checkCollisions() {
        const head = snake[0];

        // Wall collision
        if (
            head.x < 0 ||
            head.x >= tileCount ||
            head.y < 0 ||
            head.y >= tileCount
        ) {
            endGame();
            return;
        }

        // Self collision
        for (let i = 1; i < snake.length; i++) {
            if (snake[i].x === head.x && snake[i].y === head.y) {
                endGame();
                return;
            }
        }
    }

    function checkFruit() {
        const head = snake[0];
        if (head.x === fruit.x && head.y === fruit.y) {
            // Grow snake: add a segment at the end (duplicate last segment)
            const tail = snake[snake.length - 1];
            snake.push({ x: tail.x, y: tail.y });

            score++;
            updateScore();
            placeFruit();
        }
    }

    function maybeMoveFruitByTime() {
        const now = Date.now();
        if (now - lastFruitMoveTime >= fruitMoveInterval) {
            placeFruit(); // this also resets lastFruitMoveTime
        }
    }

    function drawGame() {
        // Clear canvas
        ctx.fillStyle = '#fdfdfd';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw fruit (reddish for "fruit")
        ctx.fillStyle = '#c0392b';
        ctx.beginPath();
        ctx.arc(
            fruit.x * tileSize + tileSize / 2,
            fruit.y * tileSize + tileSize / 2,
            tileSize / 2.5,
            0,
            Math.PI * 2
        );
        ctx.fill();

        // Draw snake (green, veggie style)
        for (let i = 0; i < snake.length; i++) {
            const seg = snake[i];
            ctx.fillStyle = i === 0 ? '#2ecc71' : '#27ae60';
            ctx.fillRect(
                seg.x * tileSize + 1,
                seg.y * tileSize + 1,
                tileSize - 2,
                tileSize - 2
            );
        }
    }

    function endGame() {
        gameOver = true;
        statusEl.textContent = 'Game Over (press Space to restart)';
    }

    // Handle keyboard input
    document.addEventListener('keydown', (e) => {
        if (gameOver && e.code === 'Space') {
            resetGame();
            return;
        }

        const key = e.key;
        let newDx = dx;
        let newDy = dy;

        if (key === 'ArrowUp') {
            newDx = 0; newDy = -1;
        } else if (key === 'ArrowDown') {
            newDx = 0; newDy = 1;
        } else if (key === 'ArrowLeft') {
            newDx = -1; newDy = 0;
        } else if (key === 'ArrowRight') {
            newDx = 1; newDy = 0;
        } else {
            return;
        }

        // Prevent reversing direction directly (when snake length > 1)
        if (snake.length > 1 && newDx === -dx && newDy === -dy) {
            return;
        }

        pendingDirection = { dx: newDx, dy: newDy };
    });

    // Start everything
    resetGame();
    drawGame();
    setInterval(gameLoop, gameTickMs);
</script>
</body>
</html>
